@implements IBrowserViewportObserver
@inject SemanticSearch Search

@using Microsoft.AspNetCore.Authorization
@using System.ComponentModel
@using RecettesFamille.Data.Repository.IRepositories
@using RecettesFamille.Dto.ModelByPage.RecetteBook
@using RecettesFamille.Dto.Models
@using RecettesFamille.Extensions


<MudGrid>
	<MudItem md="3" xs="12"> <!-- Empty to take the space --> </MudItem>
	<MudItem md="9" xs="12">
		<!-- Recherche & Filtres -->
		<MudStack Row="true" Spacing="3" StretchItems="StretchItems.Start">
			<MudStack Spacing="0">
				<MudTextField T="string" @bind-Value="_searchString" Label="Rechercher des recettes ..." Variant="Variant.Outlined" Class="ma-0"
							  Immediate="true" OnKeyDown="OnKeyDown" Clearable="true" OnClearButtonClick="@Ask" />
				<MudProgressLinear Color="Color.Primary" Indeterminate="_workInProgress" Rounded="true" Class="mx-2" Style="width: auto; height: 2px; " />
			</MudStack>
			<MudButton Variant="Variant.Filled" StartIcon="@Icons.Material.Filled.Search" DropShadow="false" Color="Color.Primary" Class="py-0" OnClick="@Ask">Je suis curieux</MudButton>
		</MudStack>
	</MudItem>
</MudGrid>

<MudGrid>
	<MudItem md="3" xs="12">
		<MudStack>

			<MudExpansionPanels Dense="true">
				<MudExpansionPanel Expanded="@(breakpoint > Breakpoint.Sm)">
					<TitleContent>
						<div class="d-flex">
							<MudIcon Icon="@Icons.Material.Filled.Sort" class="mr-3" Size="Size.Medium"></MudIcon>
							<MudText Typo="Typo.subtitle2">Trie</MudText>
						</div>
					</TitleContent>
					<ChildContent>
						<MudRadioGroup T="Direction" Value="_selectedDirection" ValueChanged="OnSelectedSortChanged">
							<MudRadio Value="Direction.Alphabetique" Color="Color.Primary">Alphabetique</MudRadio>
							<MudRadio Value="Direction.DateAjout" Color="Color.Primary">Dernières recettes en haut</MudRadio>
						</MudRadioGroup>
					</ChildContent>
				</MudExpansionPanel>
			</MudExpansionPanels>

			<MudExpansionPanels Dense="true">
				<MudExpansionPanel Expanded="@(breakpoint > Breakpoint.Sm)">
					<TitleContent>
						<div class="d-flex">
							<MudIcon Icon="@Icons.Material.Filled.FilterAlt" class="mr-3" Size="Size.Medium"></MudIcon>
							<MudText Typo="Typo.subtitle2">Filtre par catégories</MudText>
						</div>
					</TitleContent>
					<ChildContent>

						<MudList T="string" SelectionMode="SelectionMode.MultiSelection" Dense="true" SelectedValuesChanged="OnSelectedTagChanged">
							@foreach (var item in Tags.EmptyIfNull().OrderBy(c => c.TagName))
							{
								<MudListItem Dense="true" Text="@item.TagName" />
							}
						</MudList>

					</ChildContent>
				</MudExpansionPanel>
			</MudExpansionPanels>

		</MudStack>
	</MudItem>
	<MudItem md="9" xs="12">
		<MudPaper Elevation="1">
			<MudTable Items="Recipes" Hover="true" Breakpoint="Breakpoint.None" LoadingProgressColor="Color.Info" Class="mud-table-extra-dense"
					  Dense="true" Height="calc(100vh - 145px)">
				<RowTemplate>
					<MudTd>
						<MudText Typo="Typo.subtitle2">
							@context.Name
						</MudText>
					</MudTd>

					<MudHidden Breakpoint="Breakpoint.SmAndDown">
						<MudTd>
							@foreach (var item in context.Tags.Split("|", StringSplitOptions.RemoveEmptyEntries))
							{
								<MudChip T="string" Variant="Variant.Text" Size="Size.Small" Color="Color.Inherit">@item</MudChip>
							}
						</MudTd>
					</MudHidden>

					<MudTd>
						<MudIconButton Href="@($"/recette/{context.Id}")" Icon="@Icons.Material.Filled.RemoveRedEye" Color="Color.Primary" Size="Size.Small" />
					</MudTd>
				</RowTemplate>

				<PagerContent>
					<MudTablePager PageSizeOptions="new int[] { 50, 100, 150, 200, int.MaxValue }"
								   RowsPerPageString="Elements par page :"
								   AllItemsText="Tout"
								   InfoFormat="{first_item}-{last_item} sur {all_items}" />
				</PagerContent>
			</MudTable>
		</MudPaper>

	</MudItem>
</MudGrid>

@code {
	public enum Direction
	{
		Alphabetique,
		DateAjout
	}
	[Inject] IRecipeRepository RecipeRepository { get; set; } = null!;
	[Inject] ITagRepository TagRepository { get; set; } = null!;
	[Inject] IBrowserViewportService BrowserViewportService { get; set; } = null!;

	List<RecipeForListDto> Recipes { get; set; } = new();
	List<TagDto> Tags { get; set; } = new();
	Breakpoint breakpoint { get; set; }

	public Guid Id { get; } = Guid.NewGuid();

	Direction _selectedDirection = Direction.Alphabetique;
	bool _sortDescending = false;
	string _searchString = string.Empty;
	bool _workInProgress = false;


	protected override async Task OnParametersSetAsync()
	{
		var result = await RecipeRepository.GetAllLightRecipe();

		Recipes = ApplySort(result).ToList();
		Tags = await TagRepository.GetAllVisible();

		breakpoint = await BrowserViewportService.GetCurrentBreakpointAsync();
	}

	public async Task OnSelectedSortChanged(Direction selectedDirection)
	{
		_selectedDirection = selectedDirection;
		Recipes = ApplySort(Recipes).ToList();
		await InvokeAsync(StateHasChanged);
	}

	private async Task OnSortDirectionChanged(bool value)
	{
		_sortDescending = value;
		Recipes = ApplySort(Recipes).ToList();
		await InvokeAsync(StateHasChanged);
	}

	public Task OnSelectedTagChanged(IReadOnlyCollection<string>? strings)
	{
		return RefreshRecipeList(strings);
	}

	public async Task RefreshRecipeList(IReadOnlyCollection<string>? strings)
	{
		var result = await RecipeRepository.GetAllLightRecipe(strings?.ToArray() ?? Array.Empty<string>());
		Recipes = ApplySort(result).ToList();
		await InvokeAsync(StateHasChanged);
	}

	private IEnumerable<RecipeForListDto> ApplySort(IEnumerable<RecipeForListDto> source)
	{
		return _selectedDirection switch
		{
			Direction.DateAjout => source.OrderByDescending(s => s.CreatedDate),
			Direction.Alphabetique => source.OrderBy(s => s.Name)
		};
	}

	// Handle the key down event to detect Enter key presses
	private async Task OnKeyDown(KeyboardEventArgs e)
	{
		if (e.Key == "Enter")
		{
			await Ask();
		}
	}


	public Task NotifyBrowserViewportChangeAsync(BrowserViewportEventArgs browserViewportEventArgs)
	{
		return Task.CompletedTask;
	}




	#region AI

	public async Task Ask()
	{
		_workInProgress = true;
		await InvokeAsync(StateHasChanged);
		try
		{
			if (string.IsNullOrWhiteSpace(_searchString))
			{
				var result = await RecipeRepository.GetAllLightRecipe();
				Recipes = ApplySort(result).ToList();
				return;
			}

			var resultFromSementicSearch = await SearchAsync(_searchString);
			var recipes = await RecipeRepository.GetAllLightRecipe(resultFromSementicSearch.ToArray());
			Recipes = ApplySort(recipes).ToList();
		}
		finally
		{
			_workInProgress = false;
			await InvokeAsync(StateHasChanged);
		}
	}


	[Description("Searches for information using a phrase or keyword")]
	private async Task<IEnumerable<int>> SearchAsync(
		[Description("The phrase to search for.")] string searchPhrase,
		[Description("If possible, specify the recipe name to search that recipe only. If not provided or empty, the search includes all recipes.")] string? recipeName = null)
	{
		await InvokeAsync(StateHasChanged);
		var results = await Search.SearchLightAsync(searchPhrase, maxResults: 100);
		return results.Select(result => result.RecipeId);
	}


	#endregion

}